<?php

namespace App\Library;
use App\Review;
use App\User;
use App\Recommendation;
use App\Circle;

class RatingSystem {

    protected $review;
    protected $user;
    protected $circle;

    public function __construct(Circle $circle, User $user, Review $review)
    {
        $this->circle = $circle;
        $this->user = $user;
        $this->review = $review;
    }

    /**
     * Generate a specified number of new recommendations for the selected user
     *
     * @param int $user - user_id value
     * @param int $count - number of recommendations to add, defaults to 1
     * @return void
     */
    public function generateRecommendation(int $user, $count = 1)
    {
        $circleReviews = $this->circle->getCircleReviews($user);
        $userReviews = $this->user->find($user)->reviews;

        $circleShowReviews = $this->review->filterForShows($circleReviews);
        $userShowReviews = $this->review->filterForShows($userReviews);

    }

    public function generateCircle(int $user)
    {
        $otherUsers = $this->user->where('user_id', '!=', $user)->get('user_id');
        $userReviews = $this->review->where('user_id', $user);
        $similarityScores = $this->getSimilarityScores($userReviews, $otherUsers);
        $mostSimilar = json_encode($this->rankMostSimilar($similarityScores));

        return $this->createCircle($user, $mostSimilar);
    }

    /**
     * 
     *
     * @param int $user - user_id
     * @param string $circle - JSON string of the user_id's of that user's circle
     * @return void
     */
    public function createCircle(int $user, string $circle) 
    {    
        if ($existing = $this->circle->where('user_id', $user)->get()) {
            $existing->circle = $circle;
            $existing->save();
        } else {
            $this->circle->user_id = $user;
            $this->circle->circle = $circle;
            $this->circle->save();
        }

        return true;
    }

    /**
     * Calculates the similarity of vector arrays generated by the assembleVector() method.
     * Since the keys are integers, it uses the "+" operator rather than array_merge to 
     * remove duplicate keys.
     * 
     * Array format: [int "show / season / episode id" => int "tier rating"]
     *
     * @param array $vector1 - The current user's set of ratings
     * @param array $vector2 - The comparison user's set of ratings
     * @return float
     */
    public function cosineSimilarity(array $vector1, array $vector2)
    {
        $combinedVectorKeys = array_keys($vector1 + $vector2);
		$dotProduct = 0;
		$magnitude1 = 0;
		$magnitude2 = 0;
		foreach ($combinedVectorKeys as $key) 
		{
			$vectorValue1 = isset($vector1[$key]) ? $vector1[$key] : 0;
			$vectorValue2 = isset($vector2[$key]) ? $vector2[$key] : 0;
			$dotProduct += ($vectorValue1 * $vectorValue2);
			$magnitude1 += ($vectorValue1 ** 2);
			$magnitude2 += ($vectorValue2 ** 2);
		}
		$magnitude1 = sqrt($magnitude1);
		$magnitude2 = sqrt($magnitude2);
        $similarity = $dotProduct / ($magnitude1 * $magnitude2);
        
		return $similarity;
    }

    public function assembleVector(Collection $reviews, string $category)
    {
        switch ($category) {
            case 'show_id':
                $filtered = $review->filterForShows($reviews)->only(['show_id', 'tier']);
                break;
            
            case 'season_id':
                $filtered = $review->filterForSeasons($reviews)->only(['season_id', 'tier']);
                break;

            case 'episode_id':
                $filtered = $review->filterForEpisodes($reviews)->only(['episode_id', 'tier']);
                break;
        }

        return $filtered->toArray();
    }

    public function getSimilarityScores(Collection $userReviews, Collection $otherUsers)
    {
        $userShows = $this->assembleVector($userReviews, 'show_id');
        $userSeasons = $this->assembleVector($userReviews, 'season_id');
        $userEpisodes = $this->assembleVector($userReviews, 'episode_id'); 
        $similarityScore = [];
        
        foreach ($otherUsers as $other) {
            $otherReviews = $this->review->where('user_id', $other);
            
            $otherVector = $this->assembleVector($otherReviews, 'show_id');
            $otherScore[] = $this->cosineSimilarity($userShows, $otherVector);

            $otherVector = $this->assembleVector($otherReviews, 'season_id');
            $otherScore[] = $this->cosineSimilarity($userSeasons, $otherVector);

            $otherVector = $this->assembleVector($otherReviews, 'episode_id');
            $otherScore[] = $this->cosineSimilarity($userEpisodes, $otherVector);

            $similarityScore[] = [$other => $otherScore];
        }

        return $similarityScore;
    }

    public function rankMostSimilar(array $similarityScores)
    {
        $blendedScores = [];
        foreach ($similarityScores as $id => $scores) {
            $blendedScores = [ $id => ($scores[0] * 0.80 + $scores[1] * 0.15 + $scores[2] * .05) ];
        }

        $mostSimilar = array_slice(arsort($blendedScores), 0, 5, true);
        $mostSimilar = array_keys($mostSimilar);

        return $mostSimilar;
    }

    public function estimateRating()
    {

    }

    public function generateUserList()
    {

    }




}